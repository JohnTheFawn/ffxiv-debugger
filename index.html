<!DOCTYPE html>
<html lang="en">
  <head>
    <script type="text/javascript" src="https://ngld.github.io/OverlayPlugin/assets/shared/common.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
      body{
        margin: 0px;
        font-family: Lucida Sans Unicode,sans-serif;
        background-color: #d2d2d2;
      }

      #toolbar{
        background-color: white;
        border-bottom: 1px solid #c2c2c2;
        padding: 8px;
      }

      .card{
        background-color: white;
        border: 1px solid #c2c2c2;
        border-radius: 8px;
        padding: 8px;
        margin: 8px;
        -webkit-box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
        -moz-box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
        box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
      }

      .toolbarItem{
        display: inline-block;
      }
      .toolbarItem:not(:last-child){
        padding-right: 8px;
        border-right: 1px solid #f2f2f2;
      }

      .itemFriendlyView{
        cursor: pointer;
        margin: -8px;
        padding: 8px;
        transition: background-color .075s ease-out;
        border-radius: 8px;
      }

      .itemContainer[open] > .itemFriendlyView{
        margin-bottom: 8px;
        border-bottom: 1px solid #c2c2c2;
      }

      .itemFriendlyView:hover{
        background-color: rgba(0, 0, 0, 0.1);
      }

      .itemDetailsTable{
        width: 100%;
      }

      .itemDetailsTable, .itemDetailsTable tr {
        border: 1px solid #c2c2c2;
        border-collapse: collapse;
      }

      .itemDetailsTable td:nth-child(3){
        border-left: 1px solid #c2c2c2;
      }

      .itemDetailsTable td {
        padding-right: 8px;
        padding-left: 8px;
      }

      .codeContainer{
        border: 1px solid #c2c2c2;
        border-radius: 8px;
        padding: 8px;
        margin-top: 8px;
        background: rgba(0, 0, 0, .03);
      }

      .displayNone{
        display: none;
      }

      .preventSelect{
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
      }

      .wordWrapAnywhere{
        word-wrap: anywhere;
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <div class="toolbarItem">
        <button id="pauseButton"  name="pause" onclick="updatePaused(this)" data-pause="true">Pause</button>
        <button id="resumeButton" name="pause" onclick="updatePaused(this)" class="displayNone">Resume</button>
      </div>
      <div class="toolbarItem">
        <input type="checkbox" id="logToConsoleCheckbox" name="logToConsole" checked onchange="updateOption('logToConsole', this.checked)"/>
        <label for="logToConsoleCheckbox">Log to Console</label>
      </div>
      <div class="toolbarItem">
        <input type="checkbox" id="logRawDataCheckbox" name="logRawData" checked onchange="updateOption('logRawData', this.checked)"/>
        <label for="logRawDataCheckbox">Log Raw Data</label>
      </div>
      <div class="toolbarItem">
        <input type="checkbox" id="limitToCharacterCheckbox" name="limitToCharacter" onchange="updateOption('limitToCharacter', this.checked)"/>
        <label for="limitToCharacterCheckbox" id="limitToCharacterLabel">Limit to {characterName}</label>
      </div>
    </div>
    <div id="main">
    </div>
  </body>
  <footer>
    <script>

      const options = {
        paused: false, // Pause all processing?
        limitToCharacter: document.getElementById('limitToCharacterCheckbox').checked, // Limit to currenct character?
        logToConsole: document.getElementById('logToConsoleCheckbox').checked, // Log to console?
        logRawData: document.getElementById('logRawDataCheckbox').checked // Log raw data?
      }

      function updateOption(optionName, value){
        options[optionName] = value;
      }
      /**
       * onclick handler for when the user clicks the Pause/Resume buttons
       *
       * @param {HTMLElement} e The pause or resume button
       */
      function updatePaused(e){
        document.getElementById('pauseButton').classList.toggle('displayNone');
        document.getElementById('resumeButton').classList.toggle('displayNone');
        updateOption(e.dataset.pause ? true : false);
      }

      // Will be set to the name of the current character
      let characterName = null;
      let characterId = null;

      // Contents vary based on messageType
      const eventType = 'LogLine';
      // 0: messageType?
      //    00: message in chat box
      //        ex: "Tonk Tonkers: hello", "There are no party members." "You change to paladin."
      //    21: use action
      //        ex: clicking a button on your hotbar such as Sentinel or Goring Blade or Arm's Length
      //    26: gained an effect
      //        ex: getting a buff like Rampart or Sentinel or Arm's Length
      //    30: lose an effect
      //        ex: Rampart or Sentinel or Arm's Length wears off


      //    ex: "21|2023-01-16T13:37:49.1410000-05:00|107CDF82|Tonk Tonkers|16|Bulwark|107CDF82|Tonk Tonkers|640F|4D8000|0|0|0|0|0|0|0|0|0|0|0|0|0|0|98900|98900|10000|10000|||-87.90|51.12|1.50|-1.54|98900|98900|10000|10000|||-87.90|51.12|1.50|-1.54|0000130D|0|1|81681bf499192d9b"
      //        messageType: 21
      //        timestamp: 2023-08-08T17:49:10.1180000-04:00
      //        actorId: 10911F96
      //        actorName: Tonk Tonkers
      //        action id: DE0
      //        action: Equilibrium
      //        targetId: 10911F96
      //        targetName: Tonk Tonkers
      //        this is some kind of flag ???: 4
      //        amount (hex, trailing 0s?): 6D510000
      /**
       * Parse a "Gained an Effect" log line
       *
       * @param {object} message The raw "Gained an Effect" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageUsedAbility(message){
        // The value is stored in hex
        // The value is also stored womewhat big endian
        // {4th digit}{5th digit}{6 digit}{7th digit}{???}{1st digit}{2nd digit}{3rd digit}
        // So we want to put the last three digits before the first 4
        // and then drop that last digit cause we don't know what it is yet
        let rawAmount = message.line[9].split('');
        rawAmount.unshift(rawAmount.pop());
        rawAmount.unshift(rawAmount.pop());
        rawAmount.unshift(rawAmount.pop());
        rawAmount.pop();
        const decimalAmount = parseInt(rawAmount.join(''), 16);

        return {
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actorId: parseInt(message.line[2], 16),
          actorName: message.line[3],
          actionId: message.line[4],
          actionName: message.line[5],
          targetId: parseInt(message.line[6], 16),
          targetName: message.line[7],
          // ???: message.line[8]
          amount: decimalAmount
        };
      }

      //    ex: "26|2023-01-16T13:37:49.1410000-05:00|4D|Bulwark|10.00|107CDF82|Tonk Tonkers|107CDF82|Tonk Tonkers|00|98900|98900|b7ca294ce31f8663"
      //        messageType: 26
      //        timestamp: 2023-01-16T13:37:49.1410000-05:00
      //        actionId: 4D
      //        actionName: Bulwark
      //        duration (seconds, 2 decimal places): 10.00
      //        actor?Id: 107CDF82
      //        actor?Name: Tonk Tonkers
      //        targetId: 107CDF82
      //        targetName: Tonk Tonkers
      /**
       * Parse a "Gained an Effect" log line
       *
       * @param {object} message The raw "Gained an Effect" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageGainEffect(message){
        return {
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actionId: message.line[2],
          actionName: message.line[3],
          duration: message.line[4],
          actorId: message.line[5],
          actorName: message.line[6],
          targetId: message.line[7],
          targetName: message.line[8]
        };
      }

      /**
       * Create a fake Gained Effect message. Useful for testing.
       *
       * @return {object} A fake gained effect message object
       */
      function createFakeMessageGainEffectMessage(){
        return {
          line: [
            26,
            new Date().toISOString(),
            '4D',
            'Bulwark',
            10.00,
            '107CDF82',
            'Tonk Tonkers',
            '107CDF82',
            'Tonk Tonkers'
          ]
        }
      }

      //    ex: "30|2023-01-16T13:37:53.8630000-05:00|4D|Bulwark|0.00|107CDF82|Tonk Tonkers|107CDF82|Tonk Tonkers|00|98900|98900|ebfc01ff60fa6c8f"
      //        messageType: 30
      //        timestamp: 2023-01-16T13:37:53.8630000-05:00
      //        actionId: 4D
      //        actionName: Bulwark
      //        duration (seconds, 2 decimal places): 0.00
      //        actor?Id: 107CDF82
      //        actor?Name: Tonk Tonkers
      //        target?Id: 107CDF82
      //        target?Name: Tonk Tonkers
      /**
       * Parse a "Lost an Effect" log line
       *
       * @param {object} message The raw "Lost an Effect" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageLostEffect(message){
        return {
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actionId: message.line[2],
          actionName: message.line[3],
          duration: message.line[4],
          actorId: message.line[5],
          actorName: message.line[6],
          targetId: message.line[7],
          targetName: message.line[8]
        };
      }

      const MESSAGE_TYPE_USE_ABILITY = '21'; // Character uses ability
      const MESSAGE_TYPE_GAIN_EFFECT = '26'; // Character gains effect
      const MESSAGE_TYPE_LOSE_EFFECT = '30'; // Character loses effect
      // All Message Types
      const messageTypes = [
        MESSAGE_TYPE_USE_ABILITY,
        MESSAGE_TYPE_GAIN_EFFECT,
        MESSAGE_TYPE_LOSE_EFFECT
      ];

      const messageTypeToFriendlyMap = {
        [MESSAGE_TYPE_USE_ABILITY]: 'Used an ability',
        [MESSAGE_TYPE_GAIN_EFFECT]: 'Gained an effect',
        [MESSAGE_TYPE_LOSE_EFFECT]: 'Lost an effect',
      };

      const abilities = [];
      const actors = [];
      const targets = [];
      const actions = [];
      const effects = [];

      /**
       * Convenience function to log messages. Checks whether or not
       * logToConsole is set and whether or not the data is relevant.
       */
      function logMessage(data, actorId, targetId){
        let canLog = options.logToConsole;

        if(actorId){
          canLog = canLog && isRelatedToCurrentCharacter(actorId);
        }
        if(targetId){
          canLog = canLog && isRelatedToCurrentCharacter(targetId)
        }

        if(canLog){
          console.log(data);
        }
      }

      /**
       * If a given ID is the same as the Current Character's ID and
       * limitToCharacter is set to true.
       *
       * @param {int} id The ID to check against the Current Character's ID
       *
       * @return {boolean} Whether or not the ID is relevant based on
       *                   limitToCharacter
       */
      function isRelatedToCurrentCharacter(id){
        if(options.limitToCharacter){
          if(id !== characterId){
            return false;
          }
        }
        return true;
      }

      addOverlayListener(eventType, (data) => {
        const messageType = data.line[0];
        if(messageTypes.includes(messageType)){
          if(!options.paused){
            if(options.logToConsole && options.logRawData){
              console.log(messageTypeToFriendlyMap[messageType] ? messageTypeToFriendlyMap[messageType] : 'Unknown message type');
              console.log(data);
            }
            switch(messageType){
              case MESSAGE_TYPE_USE_ABILITY:
                const usedAbilityMessage = parseMessageUsedAbility(data);
                logMessage(
                  usedAbilityMessage,
                  usedAbilityMessage.actorId,
                  usedAbilityMessage.targetId
                );
                if(isRelatedToCurrentCharacter(usedAbilityMessage.actorId) || isRelatedToCurrentCharacter(usedAbilityMessage.targetId)){
                  abilities.push(usedAbilityMessage);

                  appendElementToMain(
                    createUsedAbilityElement(
                      data
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_GAIN_EFFECT:
                const gainedEffectMessage = parseMessageGainEffect(data);
                logMessage(
                  gainedEffectMessage,
                  gainedEffectMessage.actorId,
                  gainedEffectMessage.targetId
                );
                if(isRelatedToCurrentCharacter(gainedEffectMessage.actorId) || isRelatedToCurrentCharacter(gainedEffectMessage.targetId)){
                  effects.push(gainedEffectMessage);

                  appendElementToMain(
                    createGainedEffectElement(
                      data
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_LOSE_EFFECT:
                const lostEffectMessage = parseMessageLostEffect(data);
                logMessage(
                  lostEffectMessage,
                  lostEffectMessage.actorId,
                  lostEffectMessage.targetId
                );
                if(isRelatedToCurrentCharacter(lostEffectMessage.actorId) || isRelatedToCurrentCharacter(lostEffectMessage.targetId)){
                  effects.push(lostEffectMessage);

                  appendElementToMain(
                    createLostEffectElement(
                      data
                    )
                  );
                }

                break;
            }
          }
        }
      });
      // Set the player's character name so we know who they are later
      addOverlayListener('ChangePrimaryPlayer', (data) => {
        characterName = data.charName;
        characterId = data.charID;
        const limitToCharacterLabel = document.getElementById('limitToCharacterLabel');
        limitToCharacterLabel.innerHTML = limitToCharacterLabel.innerHTML.replace('{characterName}', data.charName);
      });
      startOverlayEvents();

      /**
       * Add a string to the page
       *
       * @param {string} content The string to add to the page
       */
      function appendStringToMain(content){
        const mainElement = document.getElementById('main');
        const newElement = document.createElement('div');
        newElement.innerHTML = content;
        mainElement.appendChild(newElement);
      }

      /**
       * Add a json object to the page
       *
       * @param {object} json The json to be added to the page
       */
      function appendJsonToMain(json){
        const mainElement = document.getElementById('main');
        const newElement = document.createElement('code');
        newElement.innerHTML = JSON.stringify(json);
        mainElement.appendChild(newElement);
      }

      /**
       * Append an element to the main element
       *
       * @param {HTMLElement} element The element to append
       */
      function appendElementToMain(element){
        document.getElementById('main').appendChild(element);
      }

      /**
       * Given a Date object, creates a user friendly string to display that
       * includes Hours, Minutes, Seconds, and Milliseconds
       *
       * @param {date} timestamp The Date to convert
       *
       * @return {string} The user friendly string HH:mm:ss.SSS
       */
      function convertDateToFriendlyWithMilliseconds(timestamp){
        const hours = timestamp.getHours();
        const friendlyHours = hours < 10 ? '0' + hours : hours;
        const minutes = timestamp.getMinutes();
        const friendlyMinutes = minutes < 10 ? '0' + minutes : minutes;
        const seconds = timestamp.getSeconds();
        const friendlySeconds = seconds < 10 ? '0' + seconds : seconds;
        const milliseconds = timestamp.getMilliseconds();
        const friendlyMilliSeconds = milliseconds < 100 ? '0' + ( milliseconds < 10 ? '0' + milliseconds : milliseconds) : milliseconds;
        return `${friendlyHours}:${friendlyMinutes}:${friendlySeconds}.${friendlyMilliSeconds}`;
      }

      /**
       * Given an array of strings, this will return a table row with each
       * element in it's own column in the row.
       *
       * @param {array} elements An array of strings to put into table columns
       *
       * @return {HTMLElement} The newly created table row element
       */
      function createTableRowFromArray(elements){
        const newRow = document.createElement('tr');
        elements.forEach(element => {
          const newColumn = document.createElement('td');
          newRow.appendChild(newColumn);
          const content = document.createTextNode(element);
          newColumn.appendChild(content);
        });
        return newRow;
      }

      /**
       * Given content, create a code block and put the content inside of it
       *
       * @param {string} content The content to put inside of the code block
       *
       * @return {HTMLObject} The new code block element
       */
      function createCodeBlock(content){
        const codeTagContainer = document.createElement('div');
        codeTagContainer.classList.add('codeContainer');
        const codeTag = document.createElement('code');
        codeTag.classList.add('wordWrapAnywhere');
        codeTag.innerHTML = JSON.stringify(content);
        codeTagContainer.appendChild(codeTag);
        return codeTagContainer
      }

      /**
       * Given a usedAbilityMessage, create an HTML table with it's data
       *
       * @param {object} usedAbilityMessage The parsed used ability message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createUsedAbilityTable(usedAbilityMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          usedAbilityMessage.actorName,
          'Action',
          usedAbilityMessage.actionName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          usedAbilityMessage.actorId,
          'Action ID',
          usedAbilityMessage.actionId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          usedAbilityMessage.targetName,
          'Amount',
          usedAbilityMessage.amount
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          usedAbilityMessage.targetId,
          'Message Type',
          usedAbilityMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(usedAbilityMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Used an Ability" element to display the "Used an Ability" log
       * lines
       *
       * @param {object} rawData The raw, unparsed, gained effect object
       *
       * @return {HTMLObject} The newly created element
       */
      function createUsedAbilityElement(rawData){
        const usedAbilityMessage = parseMessageUsedAbility(rawData);
        // Container for the used messages
        const usedAbilityElement = document.createElement('details');
        usedAbilityElement.classList.add('card');
        usedAbilityElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        usedAbilityElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(usedAbilityMessage.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor using an Ability on a Target
        const friendlyActorElement = document.createElement('span');
        let friendlyAmountText = usedAbilityMessage.targetName ? ` on <b>${usedAbilityMessage.targetName}</b>` : '';
        friendlyAmountText += !isNaN(usedAbilityMessage.amount) ? ' for <b>' + usedAbilityMessage.amount + '</b>': '';
        friendlyActorElement.innerHTML = `
          <b>${usedAbilityMessage.actorName}</b>
          used
          <b>${usedAbilityMessage.actionName}</b>
          ${friendlyAmountText}
        `;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        usedAbilityElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createUsedAbilityTable(usedAbilityMessage)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(usedAbilityMessage);
        usedAbilityElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(rawData);
        usedAbilityElement.appendChild(rawView);

        return usedAbilityElement;
      }

      /**
       * Given a gainedEffectMessage, create an HTML table with it's data
       *
       * @param {object} effectMessage The parsed gained effect message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createGainedEffectTable(effectMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          effectMessage.actorName,
          'Action',
          effectMessage.actionName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          effectMessage.actorId,
          'Action ID',
          effectMessage.actionId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          effectMessage.targetName,
          'Duration',
          effectMessage.duration
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          effectMessage.targetId,
          'Message Type',
          effectMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(effectMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Gained Effect" element to display the "Gained an Effect" log
       * lines
       *
       * @param {object} rawData The raw, unparsed, gained effect object
       *
       * @return {HTMLObject} The newly created element
       */
      function createGainedEffectElement(rawData){
        const effectMessage = parseMessageGainEffect(rawData);
        // Container for the Gained Effect messages
        const gainedEffectElement = document.createElement('details');
        gainedEffectElement.classList.add('card');
        gainedEffectElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        gainedEffectElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(effectMessage.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor applying the effect to the target
        const friendlyActorElement = document.createElement('span');
        friendlyActorElement.innerHTML = `
          <b>${effectMessage.actorName}</b>
          applied
          <b>${effectMessage.actionName}</b>
          to
          <b>${effectMessage.targetName}</b>
        `;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        gainedEffectElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createGainedEffectTable(effectMessage)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(effectMessage);
        gainedEffectElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(rawData);
        gainedEffectElement.appendChild(rawView);

        return gainedEffectElement;
      }

      /**
       * Given a gainedEffectMessage, create an HTML table with it's data
       *
       * @param {object} effectMessage The parsed gained effect message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createLostEffectTable(effectMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          effectMessage.actorName,
          'Action',
          effectMessage.actionName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          effectMessage.actorId,
          'Action ID',
          effectMessage.actionId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          effectMessage.targetName,
          'Duration',
          effectMessage.duration
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          effectMessage.targetId,
          'Message Type',
          effectMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(effectMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      function createLostEffectElement(rawData){
        const effectMessage = parseMessageLostEffect(rawData);
        // Container for the Gained Effect messages
        const lostEffectElement = document.createElement('details');
        lostEffectElement.classList.add('card');
        lostEffectElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        lostEffectElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(effectMessage.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor applying the effect to the target
        const friendlyActorElement = document.createElement('span');
        friendlyActorElement.innerHTML = `
          <b>${effectMessage.actorName}</b>
          removed
          <b>${effectMessage.actionName}</b>
          from
          <b>${effectMessage.targetName}</b>
        `;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        lostEffectElement.appendChild(detailedView);

        // Table to hold the message information
        const lostEffectTable = createLostEffectTable(effectMessage)
        detailedView.appendChild(lostEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(effectMessage);
        lostEffectElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(rawData);
        lostEffectElement.appendChild(rawView);

        return lostEffectElement;
      }

      /*
      appendElementToMain(
        createGainedEffectElement(
          parseMessageGainEffect(
            createFakeMessageGainEffectMessage()
          )
        )
      );
      */
    </script>
  </footer>
</html>
