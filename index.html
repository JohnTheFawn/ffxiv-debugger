<!DOCTYPE html>
<html lang="en">
  <head>
    <script type="text/javascript" src="https://ngld.github.io/OverlayPlugin/assets/shared/common.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
      body{
        margin: 0px;
        font-family: Lucida Sans Unicode,sans-serif;
        background-color: #d2d2d2;
      }

      #toolbar{
        background-color: white;
        border-bottom: 1px solid #c2c2c2;
        display: flex;
        flex-direction: column;
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
      }

      #main{
        height: calc(100vh - 42px);
        margin-top: 42px;
        overflow-y: scroll;
      }

      .card{
        background-color: white;
        border: 1px solid #c2c2c2;
        border-radius: 8px;
        padding: 8px;
        margin: 8px;
        -webkit-box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
        -moz-box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
        box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
      }

      #toolbarHomeRow{
        display: flex;
      }
      #toolbarHomeRow > .toolbarItem:not(:last-child){
        padding-right: 8px;
        border-right: 1px solid #f2f2f2;
      }

      .toolbarItem{
        display: inline-block;
      }
      .toolbarItem > input,
      .toolbarItem > label{
        cursor: pointer;
      }

      .toolbarRow{
        display: flex;
        flex-direction: row;
      }
      .toolbarRow > .toolbarItem{
        display: flex;
        flex: 1;
      }
      .toolbarRow > .toolbarItem > select,
      .toolbarRow > .toolbarItem > input{
        flex: 1;
        margin-left: 8px;
      }
      .toolbarRow > .toolbarItem:not(:last-child){
        padding-right: 8px;
        border-right: 1px solid #f2f2f2;
      }
      .toolbarRow > .toolbarItem:not(:first-child){
        padding-left: 8px;
      }

      #toolbarFilters{
        position: absolute;
        top: 42px;
        width: 100%;
        box-sizing: border-box;
        padding: 0px 4px 0px 4px;
      }
      #toolbarFiltersWrapper{
        background-color: white;
        border-right: 1px solid #c2c2c2;
        border-bottom: 1px solid #c2c2c2;
        border-left: 1px solid #c2c2c2;
        border-bottom-right-radius: 8px;
        border-bottom-left-radius: 8px;
        padding: 8px;
        display: flex;
        flex-direction: column;
        -webkit-box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
        -moz-box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
        box-shadow: 2px 2px 3px 0px rgba(0,0,0,0.2);
      }
      #toolbarFiltersWrapper > .toolbarRow:not(:last-child){
        padding-bottom: 8px;
        margin-bottom: 8px;
        border-bottom: 1px solid #f2f2f2;
      }

      .itemFriendlyView{
        cursor: pointer;
        margin: -8px;
        padding: 8px;
        transition: background-color .075s ease-out;
        border-radius: 8px;
      }

      .itemFriendlyView > span:first-child{
        padding-right: 8px;
      }

      .itemContainer[open] > .itemFriendlyView{
        margin-bottom: 8px;
        border-bottom: 1px solid #c2c2c2;
      }

      .itemFriendlyView:hover{
        background-color: rgba(0, 0, 0, 0.1);
      }

      .itemDetailsTable{
        width: 100%;
      }

      .itemDetailsTable, .itemDetailsTable tr {
        border: 1px solid #c2c2c2;
        border-collapse: collapse;
      }

      .itemDetailsTable td:nth-child(3){
        border-left: 1px solid #c2c2c2;
      }

      .itemDetailsTable td {
        padding-right: 8px;
        padding-left: 8px;
      }

      .codeContainer{
        border: 1px solid #c2c2c2;
        border-radius: 8px;
        padding: 8px;
        margin-top: 8px;
        background: rgba(0, 0, 0, .03);
      }

      .displayNone{
        display: none;
      }

      .preventSelect{
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
      }

      .wordWrapAnywhere{
        word-wrap: anywhere;
      }
    </style>
  </head>
  <body>
    <div id="toolbar" class="preventSelect">
      <div id="toolbarHomeRow">
        <div class="toolbarItem">
          <button id="pauseButton"  name="pause" onclick="updatePaused(this)" data-pause="true">Pause</button>
          <button id="resumeButton" name="pause" onclick="updatePaused(this)" class="displayNone">Resume</button>
          <button id="buttonToggleFilters" onclick="clearOnClickHandler()">
            Clear
          </button>
        </div>
        <div class="toolbarItem">
          <input type="checkbox" id="logToConsoleCheckbox" name="logToConsole" checked onchange="updateOption('logToConsole', this.checked)"/>
          <label for="logToConsoleCheckbox">Log to Console</label>
        </div>
        <div class="toolbarItem">
          <input type="checkbox" id="logRawDataCheckbox" name="logRawData" checked onchange="updateOption('logRawData', this.checked)"/>
          <label for="logRawDataCheckbox">Log Raw Data</label>
        </div>
        <div class="toolbarItem">
          <input type="checkbox" id="limitToCharacterCheckbox" name="limitToCharacter" onchange="updateOption('limitToCharacter', this.checked)"/>
          <label for="limitToCharacterCheckbox" id="limitToCharacterLabel">Limit to {characterName}</label>
        </div>
        <div class="toolbarItem" style="flex: 1; text-align: right;">
          <button id="buttonToggleFilters" onclick="toggleFilters()">
            Filters
          </button>
        </div>
      </div>
    </div>
    <div id="toolbarFilters" class="displayNone">
      <div id="toolbarFiltersWrapper">
        <div class="toolbarRow">
          <div class="toolbarItem" style="flex: 1; display: flex;">
            <label for="inputFilterFriendlyText" id="inputFilterFriendlyTextLabel">Search</label>
            <input
              type="search"
              id="inputFilterFriendlyText"
              name="filterFriendlyText"
              onchange="updateFilter('filterFriendlyText', this.value, 200)"
              onkeyup="updateFilter('filterFriendlyText', this.value, 200)"/>
          </div>
        </div>
        <div class="toolbarRow">
          <div class="toolbarItem">
            <label for="inputMessageTypeDropdown" id="inputMessageTypeDropdownLabel">Message Type</label>
            <select
              type="search"
              id="inputMessageTypeDropdown"
              name="messageTypeDropdown"
              onchange="updateFilter('filterMessageType', this.value)"
            >
              <option value=""/>
            </select>
          </div>
          <div class="toolbarItem">
            <label for="inputActorIdDropdown" id="inputActorIdDropdownLabel">Actor</label>
            <select
              type="search"
              id="inputActorIdDropdown"
              name="actorDropdownId"
              onchange="updateFilter('filterActorId', this.value)"
            >
              <option value=""/>
            </select>
          </div>
        </div>
        <div class="toolbarRow">
          <div class="toolbarItem">
            <label for="inputActionIdDropdown" id="inputActionIdDropdownLabel">Action</label>
            <select
              type="search"
              id="inputActionIdDropdown"
              name="actionIdDropdown"
              onchange="updateFilter('filterActionId', this.value)"
            >
              <option value=""/>
            </select>
          </div>
          <div class="toolbarItem">
            <label for="inputTargetIdDropdown" id="inputTargetIdDropdownLabel">Target</label>
            <select
              type="search"
              id="inputTargetIdDropdown"
              name="targetIdDropdown"
              onchange="updateFilter('filterTargetId', this.value)"
            >
              <option value=""/>
            </select>
          </div>
          <div class="toolbarItem">
            <label for="inputEffectIdDropdown" id="inputEffectIdDropdownLabel">Effect</label>
            <select
              type="search"
              id="inputEffectIdDropdown"
              name="effectIdDropdown"
              onchange="updateFilter('filterEffectId', this.value)"
            >
              <option value=""/>
            </select>
          </div>
        </div>
      </div>
    </div>
    <div id="main">
    </div>
  </body>
  <footer>
    <script>

      const options = {
        paused: false, // Pause all processing?
        limitToCharacter: document.getElementById('limitToCharacterCheckbox').checked, // Limit to currenct character?
        logToConsole: document.getElementById('logToConsoleCheckbox').checked, // Log to console?
        logRawData: document.getElementById('logRawDataCheckbox').checked // Log raw data?
      }

      /**
       * Update an option
       *
       * @param {string} optionName The option to update
       * @param {*} value The value to set the option to
       */
      function updateOption(optionName, value){
        options[optionName] = value;
      }

      /**
       * onclick handler for when the user clicks the Pause/Resume buttons
       *
       * @param {HTMLElement} e The pause or resume button
       */
      function updatePaused(e){
        document.getElementById('pauseButton').classList.toggle('displayNone');
        document.getElementById('resumeButton').classList.toggle('displayNone');
        updateOption('paused', e.dataset.pause ? true : false);
      }

      // Will be set to the name of the current character
      let characterName = null;
      let characterId = null;

      // Contents vary based on messageType
      // 0: messageType?
      //    00: message in chat box
      //        ex: "Tonk Tonkers: hello", "There are no party members." "You change to paladin."
      //    21: use action
      //        ex: clicking a button on your hotbar such as Sentinel or Goring Blade or Arm's Length
      //    26: gained an effect
      //        ex: getting a buff like Rampart or Sentinel or Arm's Length
      //    30: lose an effect
      //        ex: Rampart or Sentinel or Arm's Length wears off


      //    ex: "03|2023-08-24T13:58:39.5300000-04:00|1002E6E1|Tonk Tonkers|13|5A|0000|4A|Coeurl|0|0|116557|117930|10000|10000|||378.21|-204.52|20.34|-2.09|a7c819371491e446"
      //        [0]  messageType: 03
      //        [1]  timestamp: 2023-08-24T12:40:49.0230000-04:00
      //        [2]  actorId: 1002E6E1
      //        [3]  actorName: Tonk Tonkers
      //        [4]  jobId: 13
      //        [5]  level: 5A
      //        [6]  ??: 0000
      //        [7]  ??: 4A
      //        [8]  ??: Coeurl
      //        [9]  ??: 0
      //        [10] ??: 0
      //        [11] currentHp: 116557
      //        [12] totalHp: 117930
      //        [13] currentMp: 10000
      //        [14] totalMP: 10000
      /**
       * Parse a "Combatant Added" log line
       *
       * @param {object} message The raw "Combatant Added" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageAddCombatant(message){
        return {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actorId: parseInt(message.line[2], 16),
          actorName: message.line[3],
          jobId: parseInt(message.line[4], 16),
          level: parseInt(message.line[5], 16),
          currentHp: message.line[11],
          totalHp: message.line[12],
          currentMp: message.line[13],
          totalMp: message.line[14],

        };
      }

      //    ex: "04|2023-08-24T13:59:03.9090000-04:00|1002E6E1|Tonk Tonkers|22|57|0000|4A|Coeurl|0|0|31486|31486|10000|10000|||-108.19|289.00|-19.23|0.82|57cc6bfedad6ab98"
      //        [0]  messageType: 03
      //        [1]  timestamp: 2023-08-24T12:40:49.0230000-04:00
      //        [2]  actorId: 1002E6E1
      //        [3]  actorName: Tonk Tonkers
      //        [4]  jobId: 22
      //        [5]  level: 57
      //        [6]  ??: 0000
      //        [7]  ??: 4A
      //        [8]  ??: Coeurl
      //        [9]  ??: 0
      //        [10] ??: 0
      //        [11] currentHp: 38060
      //        [12] totalHp: 38060
      //        [13] currentMp: 7000
      //        [14] totalMP: 10000
      /**
       * Parse a "Combatant Added" log line
       *
       * @param {object} message The raw "Combatant Added" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageRemoveCombatant(message){
        return {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actorId: parseInt(message.line[2], 16),
          actorName: message.line[3],
          jobId: parseInt(message.line[4], 16),
          level: parseInt(message.line[5], 16),
          currentHp: message.line[11],
          totalHp: message.line[12],
          currentMp: message.line[13],
          totalMp: message.line[14]
        };
      }

      //    ex: "20|2023-08-21T15:04:24.6500000-04:00|107CDF82|Tonk Tonkers|05|Teleport|107CDF82|Tonk Tonkers|5.000|-119.53|-130.91|2.00|2.57|36b21e47de5a2d13"
      //        [0] messageType: 20
      //        [1] timestamp: 2023-08-21T15:04:24.6500000-04:00
      //        [2] actorId: 107CDF82
      //        [3] actorName: Tonk Tonkers
      //        [4] actionId: 05
      //        [5] actionName: Teleport
      //        [6] targetId: 107CDF82
      //        [7] targetName: Tonk Tonkers
      //        [8] castTime: 5.000
      /**
       * Parse a "Starts Casting" log line
       *
       * @param {object} message The raw "Starts Casting" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageStartsCasting(message){
        return {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actorId: parseInt(message.line[2], 16),
          actorName: message.line[3],
          actionId: parseInt(message.line[4], 16),
          actionName: message.line[5],
          targetId: parseInt(message.line[6], 16),
          targetName: message.line[7],
          castTime: parseFloat(message.line[8])
        };
      }


      //    ex: "21|2023-01-16T13:37:49.1410000-05:00|107CDF82|Tonk Tonkers|16|Bulwark|107CDF82|Tonk Tonkers|640F|4D8000|0|0|0|0|0|0|0|0|0|0|0|0|0|0|98900|98900|10000|10000|||-87.90|51.12|1.50|-1.54|98900|98900|10000|10000|||-87.90|51.12|1.50|-1.54|0000130D|0|1|81681bf499192d9b"
      //        [0]  messageType: 21
      //        [1]  timestamp: 2023-08-08T17:49:10.1180000-04:00
      //        [2]  actorId: 107CDF82
      //        [3]  actorName: Tonk Tonkers
      //        [4]  actionId/effectId: 16
      //        [5]  actionName/effectName: Bulwark
      //        [6]  targetId: 107CDF82
      //        [7]  targetName: Tonk Tonkers
      //        [8]  ???: 640F
      //        [9]  amount (hex and shifted): 4D8000
      /**
       * Parse a "Gained an Effect" log line
       *
       * @param {object} message The raw "Gained an Effect" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageUsedAbility(message){

        const mysteryFlag = message.line[10];

        const response = {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actorId: parseInt(message.line[2], 16),
          actorName: message.line[3],
          actionId: parseInt(message.line[4], 16),
          actionName: message.line[5],
          targetId: parseInt(message.line[6], 16),
          targetName: message.line[7],
          // ???: message.line[8]
        };

        if(mysteryFlag === '0'){
          response.effectId = parseInt(message.line[4], 16);
          response.effectName = message.line[5];
        }
        else{
          // The value is stored in hex
          // The value is also stored womewhat big endian
          // {4th digit}{5th digit}{6 digit}{7th digit}{???}{1st digit}{2nd digit}{3rd digit}
          // So we want to put the last three digits before the first 4
          // and then drop that last digit cause we don't know what it is yet
          let rawAmount = message.line[9].split('');
          rawAmount.unshift(rawAmount.pop());
          rawAmount.unshift(rawAmount.pop());
          rawAmount.unshift(rawAmount.pop());
          rawAmount.pop();
          const decimalAmount = parseInt(rawAmount.join(''), 16);
          response.amount = decimalAmount;
        }

        return response;
      }

      //    ex: "26|2023-01-16T13:37:49.1410000-05:00|4D|Bulwark|10.00|107CDF82|Tonk Tonkers|107CDF82|Tonk Tonkers|00|98900|98900|b7ca294ce31f8663"
      //        [0]  messageType: 26
      //        [1]  timestamp: 2023-01-16T13:37:49.1410000-05:00
      //        [2]  actionId: 4D
      //        [3]  actionName: Bulwark
      //        [4]  duration (seconds, 2 decimal places): 10.00
      //        [5]  actorId: 107CDF82
      //        [6]  actorName: Tonk Tonkers
      //        [7]  targetId: 107CDF82
      //        [8]  targetName: Tonk Tonkers
      //        [9]  ???: 00
      //        [10] actor?target?Hp: 98900
      //        [11] actor?target?Hp: 98900
      /**
       * Parse a "Gained an Effect" log line
       *
       * @param {object} message The raw "Gained an Effect" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageGainEffect(message){
        return {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          effectId: parseInt(message.line[2], 16),
          effectName: message.line[3],
          duration: message.line[4],
          actorId: parseInt(message.line[5], 16),
          actorName: message.line[6],
          targetId: parseInt(message.line[7], 16),
          targetName: message.line[8]
        };
      }

      /**
       * Create a fake Gained Effect message. Useful for testing.
       *
       * @return {object} A fake gained effect message object
       */
      function createFakeMessageGainEffectMessage(){
        return {
          line: [
            26,
            new Date().toISOString(),
            '4D',
            'Bulwark',
            10.00,
            '107CDF82',
            'Tonk Tonkers',
            '107CDF82',
            'Tonk Tonkers'
          ]
        }
      }

      //    ex: "30|2023-01-16T13:37:53.8630000-05:00|4D|Bulwark|0.00|107CDF82|Tonk Tonkers|107CDF82|Tonk Tonkers|00|98900|98900|ebfc01ff60fa6c8f"
      //        [0] messageType: 30
      //        [1] timestamp: 2023-01-16T13:37:53.8630000-05:00
      //        [2] actionId: 4D
      //        [3] actionName: Bulwark
      //        [4] duration (seconds, 2 decimal places): 0.00
      //        [5] actorId: 107CDF82
      //        [6] actorName: Tonk Tonkers
      //        [7] targetId: 107CDF82
      //        [8] targetName: Tonk Tonkers
      //        [10] actor?target?Hp: 98900
      //        [11] actor?target?Hp: 98900
      /**
       * Parse a "Lost an Effect" log line
       *
       * @param {object} message The raw "Lost an Effect" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageLostEffect(message){
        return {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          effectId: parseInt(message.line[2], 16),
          effectName: message.line[3],
          duration: message.line[4],
          actorId: parseInt(message.line[5], 16),
          actorName: message.line[6],
          targetId: parseInt(message.line[7], 16),
          targetName: message.line[8]
        };
      }

      //    ex: "39|2023-08-24T13:38:25.4760000-04:00|1002E6E1|Tonk Tonkers|117930|117930|9800|10000|||380.96|-181.85|20.42|1.65|9891b2cace489cea"
      //        [0]  messageType: 39
      //        [1]  timestamp: 2023-08-24T13:38:25.4760000-04:00
      //        [2]  actorId: 1002E6E1
      //        [3]  actorName: Tonk Tonkers
      //        [4]  currentHp: 117930
      //        [5]  totalHp: 117930
      //        [6]  currentMp: 9800
      //        [7]  totalMp: 10000
      /**
       * Parse a "Health update" log line
       *
       * @param {object} message The raw "Health update" message object
       *
       * @return {object} A parsed and labeled object containing the data.
       */
      function parseMessageHealthUpdate(message){
        return {
          raw: message,
          messageType: message.line[0],
          timestamp: new Date(message.line[1]),
          actorId: parseInt(message.line[2], 16),
          actorName: message.line[3],
          currentHp: message.line[4],
          totalHp: message.line[5],
          currentMp: message.line[6],
          totalMp: message.line[7]
        };
      }

      /**
       * Sometimes the values are stored as hex and shifted some number of bits
       * This function will shift the bits and then convert the hex
       *
       * @param {string} hexString The hex string to convert to decimal
       * @param {int} shiftAmount How many places to shift the hex values
       */
      function unshiftHexAndConvert(hexString, shiftAmount){
        // The value is stored in hex
        // The value is also stored somewhat big endian
        // {4th digit}{5th digit}{6 digit}{7th digit}{???}{1st digit}{2nd digit}{3rd digit}
        // So we want to put the last three digits before the first 4
        // and then drop that last digit cause we don't know what it is yet
        let rawAmount = hexString.split('');
        for(let i = 0; i < shiftAmount; i++){
          rawAmount.unshift(rawAmount.pop());
        }
        rawAmount.pop();
        return parseInt(rawAmount.join(''), 16);
      }

      const MESSAGE_TYPE_LOG_LINE = '00'; // Log Line, literally anything
      const MESSAGE_TYPE_CHANGE_PRIMARY_PLAYER = '02'; // ??? TODO investigate
      const MESSAGE_TYPE_ADD_COMBATANT = '03'; // ??? TODO investigate
      const MESSAGE_TYPE_REMOVE_COMBATANT = '04'; // ??? TODO investigate
      const MESSAGE_TYPE_ADD_BUFF = '05'; // ??? TODO investigate
      const MESSAGE_TYPE_REMOVE_BUFF = '06'; // ??? TODO investigate
      const MESSAGE_TYPE_FLYING_TEXT = '07'; // ??? TODO investigate
      const MESSAGE_TYPE_STARTS_CASTING = '20'; // Starts Casting
      const MESSAGE_TYPE_USE_ABILITY = '21'; // Character uses ability
      const MESSAGE_TYPE_UNKNOWN_24 = '24'; // ??? TODO investigate
      const MESSAGE_TYPE_GAIN_EFFECT = '26'; // Character gains effect
      const MESSAGE_TYPE_LOSE_EFFECT = '30'; // Character loses effect
      const MESSAGE_TYPE_UNKNOWN_37 = '37'; // ??? TODO investigate
      const MESSAGE_TYPE_UNKNOWN_38 = '38'; // ??? TODO investigate
      const MESSAGE_TYPE_HEALTH_UPDATE = '39'; // Regen tick
      const MESSAGE_TYPE_CHANGED_ZONE = '40'; // Changed Zone? TODO investigate

      // All Message Types
      const messageTypes = [
        MESSAGE_TYPE_LOG_LINE,
        MESSAGE_TYPE_CHANGE_PRIMARY_PLAYER, // ??? TODO investigate
        MESSAGE_TYPE_ADD_COMBATANT, // ??? TODO investigate
        MESSAGE_TYPE_REMOVE_COMBATANT, // ??? TODO investigate
        MESSAGE_TYPE_ADD_BUFF, // ??? TODO investigate
        MESSAGE_TYPE_REMOVE_BUFF, // ??? TODO investigate
        MESSAGE_TYPE_FLYING_TEXT, // ??? TODO investigate
        MESSAGE_TYPE_STARTS_CASTING,
        MESSAGE_TYPE_USE_ABILITY,
        MESSAGE_TYPE_UNKNOWN_24, // ??? TODO investigate
        MESSAGE_TYPE_GAIN_EFFECT,
        MESSAGE_TYPE_LOSE_EFFECT,
        MESSAGE_TYPE_UNKNOWN_37, // ??? TODO investigate
        MESSAGE_TYPE_UNKNOWN_38, // ??? TODO investigate
        MESSAGE_TYPE_HEALTH_UPDATE,
        MESSAGE_TYPE_CHANGED_ZONE
      ];

      // Friendly text for each message type
      const messageTypeToFriendlyMap = {
        [MESSAGE_TYPE_LOG_LINE]: 'Log Line',
        [MESSAGE_TYPE_CHANGE_PRIMARY_PLAYER]: 'Primary Player Changed',
        [MESSAGE_TYPE_ADD_COMBATANT]: 'Combatant Added',
        [MESSAGE_TYPE_REMOVE_COMBATANT]: 'Combatant Removed',
        [MESSAGE_TYPE_ADD_BUFF]: 'MESSAGE_TYPE_ADD_BUFF',
        [MESSAGE_TYPE_REMOVE_BUFF]: 'MESSAGE_TYPE_REMOVE_BUFF',
        [MESSAGE_TYPE_FLYING_TEXT]: 'MESSAGE_TYPE_FLYING_TEXT',
        [MESSAGE_TYPE_STARTS_CASTING]: 'Starts casting',
        [MESSAGE_TYPE_USE_ABILITY]: 'Used an ability',
        [MESSAGE_TYPE_UNKNOWN_24]: 'MESSAGE_TYPE_UNKNOWN_24',
        [MESSAGE_TYPE_GAIN_EFFECT]: 'Gained an effect',
        [MESSAGE_TYPE_LOSE_EFFECT]: 'Lost an effect',
        [MESSAGE_TYPE_UNKNOWN_37]: 'MESSAGE_TYPE_UNKNOWN_37',
        [MESSAGE_TYPE_UNKNOWN_38]: 'MESSAGE_TYPE_UNKNOWN_38',
        [MESSAGE_TYPE_UNKNOWN_38]: 'MESSAGE_TYPE_UNKNOWN_38',
        [MESSAGE_TYPE_HEALTH_UPDATE]: 'Health Update',
        [MESSAGE_TYPE_CHANGED_ZONE]: 'Changed zone?'
      };

      // Used to ignore message types so they don't get console logged or
      // displayed
      const messageTypeBlackList = [
        MESSAGE_TYPE_LOG_LINE,
        MESSAGE_TYPE_UNKNOWN_37,
        MESSAGE_TYPE_UNKNOWN_38
      ];

      // Populate the Message Type Dropdown filter with messageTypes
      const inputMessageTypeDropdown = document.getElementById('inputMessageTypeDropdown');
      messageTypes.forEach(messageType => {
        if(!messageTypeBlackList.includes(messageType)){
          const newOption = document.createElement('option');
          newOption.value = messageType;
          newOption.innerHTML = messageType + ' - ' + messageTypeToFriendlyMap[messageType];
          inputMessageTypeDropdown.appendChild(newOption);
        }
      });

      const abilities = [];
      const actors = {};
      const targets = {};
      const actions = {};
      const effects = {};

      // Will hold all newly created elements that are added to the main area
      const elements = [];
      const filters = {
        filterFriendlyText: null,
        filterMessageType: null,
        filterActorId: null,
        filterTargetId: null,
        filterActionId: null,
        filterEffectId: null
      }

      let updateFilterTimeout = null;
      function updateFilter(filterName, value, buffer){
        if(filters[filterName] !== value){
          filters[filterName] = value;
          if(buffer){
            if(updateFilterTimeout){
              clearTimeout(updateFilterTimeout);
            }
            updateFilterTimeout = setTimeout(() => {
              filterElements();
              updateFilterTimeout = null;
            }, buffer);
          }
          else{
            filterElements();
          }
        }
      }

      function filterElements(){
        elements.forEach(element => {
          if(shouldHideElement(element)){
            element.classList.add('displayNone');
          }
          else{
            element.classList.remove('displayNone');
          }
        });
      }

      function addActor(actorId, actorName){
        if(actors[actorId] === undefined){
          const newOption = document.createElement('option');
          newOption.value = actorId;
          newOption.innerHTML = `${actorName} (${actorId})`;
          document.getElementById('inputActorIdDropdown').appendChild(newOption);
        }
        // Sometimes actorName comes back null but actorId won't
        actors[actorId] = actorName ? actorName : '';
      }

      function addTarget(targetId, targetName){
        if(targets[targetId] === undefined){
          const newOption = document.createElement('option');
          newOption.value = targetId;
          newOption.innerHTML = `${targetName} (${targetId})`;
          document.getElementById('inputTargetIdDropdown').appendChild(newOption);
        }
        // Sometimes targetName comes back null but targetId won't
        targets[targetId] = targetName ? targetName : '';
      }

      function addAction(actionId, actionName){
        if(actions[actionId] === undefined){
          const newOption = document.createElement('option');
          newOption.value = actionId;
          newOption.innerHTML = `${actionName} (${actionId})`;
          document.getElementById('inputActionIdDropdown').appendChild(newOption);
        }
        // Sometimes actionName comes back null but actionId won't
        actions[actionId] = actionName ? actionName : '';
      }

      function addEffect(effectId, effectName){
        if(effects[effectId] === undefined){
          const newOption = document.createElement('option');
          newOption.value = effectId;
          newOption.innerHTML = `${effectName} (${effectId})`;
          document.getElementById('inputEffectIdDropdown').appendChild(newOption);
        }
        // Sometimes effectName comes back null but effectId won't
        effects[effectId] = effectName ? effectName : '';
      }

      function shouldHideElement(element){
        let hideElement = false;
        if(
          filters.filterFriendlyText
          && !(element.dataset.friendlyText || '').toLowerCase().includes(filters.filterFriendlyText.toLowerCase())
        ){
          hideElement = true;
        }
        if(filters.filterMessageType && element.dataset.messageType != filters.filterMessageType){
          hideElement = true;
        }
        if(filters.filterActorId && element.dataset.actorId != filters.filterActorId){
          hideElement = true;
        }
        if(filters.filterActionId && element.dataset.actionId != filters.filterActionId){
          hideElement = true;
        }
        if(filters.filterTargetId && element.dataset.targetId != filters.filterTargetId){
          hideElement = true;
        }
        if(filters.filterEffectId && element.dataset.effectId != filters.filterEffectId){
          hideElement = true;
        }
        return hideElement;
      }

      function toggleFilters(){
        document.getElementById('toolbarFilters').classList.toggle('displayNone');
      }

      /**
       * Convenience function to log messages. Checks whether or not
       * logToConsole is set and whether or not the data is relevant.
       */
      function logMessage(data, actorId, targetId){
        let canLog = options.logToConsole;

        if(actorId){
          canLog = canLog && isRelatedToCurrentCharacter(actorId);
        }
        if(targetId){
          canLog = canLog && isRelatedToCurrentCharacter(targetId)
        }

        if(canLog){
          console.log(data);
        }
      }

      /**
       * If a given ID is the same as the Current Character's ID and
       * limitToCharacter is set to true.
       *
       * @param {int} id The ID to check against the Current Character's ID
       *
       * @return {boolean} Whether or not the ID is relevant based on
       *                   limitToCharacter
       */
      function isRelatedToCurrentCharacter(id){
        if(options.limitToCharacter){
          if(id !== characterId){
            return false;
          }
        }
        return true;
      }

      addOverlayListener('LogLine', (data) => {
        const messageType = data.line[0];
        if(!options.paused){
          if(messageTypes.includes(messageType)){
            if(options.logToConsole && options.logRawData){
              console.log(
                messageTypeToFriendlyMap[messageType] ? messageTypeToFriendlyMap[messageType] : 'Unknown message type',
                data
              );
            }
            switch(messageType){
              case MESSAGE_TYPE_ADD_COMBATANT:
                const addCombatantMessage = parseMessageAddCombatant(data);
                logMessage(
                  addCombatantMessage,
                  addCombatantMessage.actorId
                );
                if(isRelatedToCurrentCharacter(addCombatantMessage.actorId)){
                  addActor(addCombatantMessage.actorId, addCombatantMessage.actorName);
                  appendElementToMain(
                    createAddCombatantElement(
                      addCombatantMessage
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_REMOVE_COMBATANT:
                const removeCombatantMessage = parseMessageRemoveCombatant(data);
                logMessage(
                  removeCombatantMessage,
                  removeCombatantMessage.actorId
                );
                if(isRelatedToCurrentCharacter(removeCombatantMessage.actorId)){
                  addActor(removeCombatantMessage.actorId, removeCombatantMessage.actorName);
                  appendElementToMain(
                    createRemoveCombatantElement(
                      removeCombatantMessage
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_STARTS_CASTING:
                const startsCastingMessage = parseMessageStartsCasting(data);
                logMessage(
                  startsCastingMessage,
                  startsCastingMessage.actorId,
                  startsCastingMessage.targetId
                );
                if(isRelatedToCurrentCharacter(startsCastingMessage.actorId) || isRelatedToCurrentCharacter(startsCastingMessage.targetId)){
                  addActor(startsCastingMessage.actorId, startsCastingMessage.actorName);
                  addTarget(startsCastingMessage.targetId, startsCastingMessage.targetName);
                  addAction(startsCastingMessage.actionId, startsCastingMessage.actionName);
                  appendElementToMain(
                    createStartsCastingElement(
                      startsCastingMessage
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_USE_ABILITY:
                const usedAbilityMessage = parseMessageUsedAbility(data);
                logMessage(
                  usedAbilityMessage,
                  usedAbilityMessage.actorId,
                  usedAbilityMessage.targetId
                );
                if(isRelatedToCurrentCharacter(usedAbilityMessage.actorId) || isRelatedToCurrentCharacter(usedAbilityMessage.targetId)){
                  addActor(usedAbilityMessage.actorId, usedAbilityMessage.actorName);
                  addTarget(usedAbilityMessage.targetId, usedAbilityMessage.targetName);
                  addAction(usedAbilityMessage.actionId, usedAbilityMessage.actionName);
                  appendElementToMain(
                    createUsedAbilityElement(
                      usedAbilityMessage
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_GAIN_EFFECT:
                const gainedEffectMessage = parseMessageGainEffect(data);
                logMessage(
                  gainedEffectMessage,
                  gainedEffectMessage.actorId,
                  gainedEffectMessage.targetId
                );
                if(isRelatedToCurrentCharacter(gainedEffectMessage.actorId) || isRelatedToCurrentCharacter(gainedEffectMessage.targetId)){
                  addActor(gainedEffectMessage.actorId, gainedEffectMessage.actorName);
                  addTarget(gainedEffectMessage.targetId, gainedEffectMessage.targetName);
                  addEffect(gainedEffectMessage.effectId, gainedEffectMessage.effectName);
                  appendElementToMain(
                    createGainedEffectElement(
                      gainedEffectMessage
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_LOSE_EFFECT:
                const lostEffectMessage = parseMessageLostEffect(data);
                logMessage(
                  lostEffectMessage,
                  lostEffectMessage.actorId,
                  lostEffectMessage.targetId
                );
                if(isRelatedToCurrentCharacter(lostEffectMessage.actorId) || isRelatedToCurrentCharacter(lostEffectMessage.targetId)){
                  addActor(lostEffectMessage.actorId, lostEffectMessage.actorName);
                  addTarget(lostEffectMessage.targetId, lostEffectMessage.targetName);
                  addEffect(lostEffectMessage.effectId, lostEffectMessage.effectName);
                  appendElementToMain(
                    createLostEffectElement(
                      lostEffectMessage
                    )
                  );
                }

                break;
              case MESSAGE_TYPE_HEALTH_UPDATE:
                const healthUpdateMessage = parseMessageHealthUpdate(data);
                logMessage(
                  healthUpdateMessage,
                  healthUpdateMessage.actorId
                );
                if(isRelatedToCurrentCharacter(healthUpdateMessage.actorId)){
                  addActor(healthUpdateMessage.actorId, healthUpdateMessage.actorName);
                  appendElementToMain(
                    createHealthUpdateElement(
                      healthUpdateMessage
                    )
                  );
                }

                break;
            }
          }
          else{
            if(options.logToConsole && options.logRawData && !messageTypeBlackList.includes(messageType)){
              console.log(
                'Unknown message type',
                data
              );
            }
          }
        }
      });
      // Set the player's character name so we know who they are later
      addOverlayListener('ChangePrimaryPlayer', (data) => {
        characterName = data.charName;
        characterId = data.charID;
        const limitToCharacterLabel = document.getElementById('limitToCharacterLabel');
        limitToCharacterLabel.innerHTML = limitToCharacterLabel.innerHTML.replace('{characterName}', data.charName);
      });
      startOverlayEvents();

      /**
       * Add a string to the page
       *
       * @param {string} content The string to add to the page
       */
      function appendStringToMain(content){
        const newElement = document.createElement('div');
        newElement.innerHTML = content;
        appendElementToMain(newElement);
      }

      /**
       * Add a json object to the page
       *
       * @param {object} json The json to be added to the page
       */
      function appendJsonToMain(json){
        const newElement = document.createElement('code');
        newElement.innerHTML = JSON.stringify(json);
        appendElementToMain.appendChild(newElement);
      }

      /**
       * Append an element to the main element
       *
       * @param {HTMLElement} element The element to append
       */
      function appendElementToMain(element){
        elements.push(element);
        if(shouldHideElement(element)){
          element.classList.add('displayNone');
        }
        document.getElementById('main').appendChild(element);
      }

      /**
       * Empty the contents of the main element
       */
      function clearMain(){
        document.getElementById('main').replaceChildren();
      }

      /**
       * Click handler for the "Clear" button, calls clearMain and console.clear
       */
      function clearOnClickHandler(){
        if(window.confirm("Are you sure you wish to clear all visible logs?")){
          clearMain();
          console.clear();
        }
      }

      /**
       * Given a Date object, creates a user friendly string to display that
       * includes Hours, Minutes, Seconds, and Milliseconds
       *
       * @param {date} timestamp The Date to convert
       *
       * @return {string} The user friendly string HH:mm:ss.SSS
       */
      function convertDateToFriendlyWithMilliseconds(timestamp){
        const hours = timestamp.getHours();
        const friendlyHours = hours < 10 ? '0' + hours : hours;
        const minutes = timestamp.getMinutes();
        const friendlyMinutes = minutes < 10 ? '0' + minutes : minutes;
        const seconds = timestamp.getSeconds();
        const friendlySeconds = seconds < 10 ? '0' + seconds : seconds;
        const milliseconds = timestamp.getMilliseconds();
        const friendlyMilliSeconds = milliseconds < 100 ? '0' + ( milliseconds < 10 ? '0' + milliseconds : milliseconds) : milliseconds;
        return `${friendlyHours}:${friendlyMinutes}:${friendlySeconds}.${friendlyMilliSeconds}`;
      }

      /**
       * Given an array of strings, this will return a table row with each
       * element in it's own column in the row.
       *
       * @param {array} elements An array of strings to put into table columns
       *
       * @return {HTMLElement} The newly created table row element
       */
      function createTableRowFromArray(elements){
        const newRow = document.createElement('tr');
        elements.forEach(element => {
          const newColumn = document.createElement('td');
          newRow.appendChild(newColumn);
          const content = document.createTextNode(element);
          newColumn.appendChild(content);
        });
        return newRow;
      }

      /**
       * Given content, create a code block and put the content inside of it
       *
       * @param {string} content The content to put inside of the code block
       *
       * @return {HTMLObject} The new code block element
       */
      function createCodeBlock(content){
        const codeTagContainer = document.createElement('div');
        codeTagContainer.classList.add('codeContainer');
        const codeTag = document.createElement('code');
        codeTag.classList.add('wordWrapAnywhere');
        codeTag.innerHTML = JSON.stringify(content);
        codeTagContainer.appendChild(codeTag);
        return codeTagContainer
      }

      /**
       * Given a removeCombatantMessage, create an HTML table with it's data
       *
       * @param {object} removeCombatantMessage The parsed combatant removed message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createRemoveCombatantTable(removeCombatantMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          removeCombatantMessage.actorName,
          'Actor ID',
          removeCombatantMessage.actorId
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Current HP',
          removeCombatantMessage.currentHp,
          'Total HP',
          removeCombatantMessage.totalHp
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Current MP',
          removeCombatantMessage.currentMp,
          'Total MP',
          removeCombatantMessage.totalMp
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Job ID',
          removeCombatantMessage.jobId,
          'Level',
          removeCombatantMessage.level
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(removeCombatantMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Combatant Removed" element to display the "Combatant Removed" log
       * lines
       *
       * @param {object} message The parsed combatant removed object
       *
       * @return {HTMLObject} The newly created element
       */
      function createRemoveCombatantElement(message){
        // Container for the starts casting messages
        const removeCombatantElement = document.createElement('details');
        removeCombatantElement.classList.add('card');
        removeCombatantElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        removeCombatantElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor starts casting an action on a Target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = `Removed Combatant: <b>${message.actorName}</b>`;
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        removeCombatantElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createRemoveCombatantTable(message)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        removeCombatantElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        removeCombatantElement.appendChild(rawView);

        // Used for searching
        removeCombatantElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          removeCombatantElement.dataset[key] = value;
        });

        return removeCombatantElement;
      }

      /**
       * Given a addCombatantMessage, create an HTML table with it's data
       *
       * @param {object} addCombatantMessage The parsed combatant added message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createAddCombatantTable(addCombatantMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          addCombatantMessage.actorName,
          'Actor ID',
          addCombatantMessage.actorId
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Current HP',
          addCombatantMessage.currentHp,
          'Total HP',
          addCombatantMessage.totalHp
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Current MP',
          addCombatantMessage.currentMp,
          'Total MP',
          addCombatantMessage.totalMp
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Job ID',
          addCombatantMessage.jobId,
          'Level',
          addCombatantMessage.level
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(addCombatantMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Combatant Added" element to display the "Combatant Added" log
       * lines
       *
       * @param {object} message The parsed combatant added object
       *
       * @return {HTMLObject} The newly created element
       */
      function createAddCombatantElement(message){
        // Container for the starts casting messages
        const addCombatantElement = document.createElement('details');
        addCombatantElement.classList.add('card');
        addCombatantElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        addCombatantElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor starts casting an action on a Target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = `New Combatant: <b>${message.actorName}</b>`;
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        addCombatantElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createAddCombatantTable(message)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        addCombatantElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        addCombatantElement.appendChild(rawView);

        // Used for searching
        addCombatantElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          addCombatantElement.dataset[key] = value;
        });

        return addCombatantElement;
      }

      /**
       * Given a startsCastingMessage, create an HTML table with it's data
       *
       * @param {object} startsCastingMessage The parsed starts casting message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createStartsCastingTable(startsCastingMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          startsCastingMessage.actorName,
          'Action',
          startsCastingMessage.actionName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          startsCastingMessage.actorId,
          'Action ID',
          startsCastingMessage.actionId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          startsCastingMessage.targetName,
          'Cast Time',
          startsCastingMessage.castTime
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          startsCastingMessage.targetId,
          'Message Type',
          startsCastingMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(startsCastingMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Starts Casting" element to display the "Starts Casting" log
       * lines
       *
       * @param {object} message The parsed gained effect object
       *
       * @return {HTMLObject} The newly created element
       */
      function createStartsCastingElement(message){
        // Container for the starts casting messages
        const startsCastingElement = document.createElement('details');
        startsCastingElement.classList.add('card');
        startsCastingElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        startsCastingElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor starts casting an action on a Target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = `<b>${message.actorName}</b> starts casting <b>${message.actionName}</b>`;
        friendlyText += message.targetName ? ` on <b>${message.targetName}</b>` : '';
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        startsCastingElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createStartsCastingTable(message)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        startsCastingElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        startsCastingElement.appendChild(rawView);

        // Used for searching
        startsCastingElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          startsCastingElement.dataset[key] = value;
        });

        return startsCastingElement;
      }

      /**
       * Given a usedAbilityMessage, create an HTML table with it's data
       *
       * @param {object} usedAbilityMessage The parsed used ability message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createUsedAbilityTable(usedAbilityMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          usedAbilityMessage.actorName,
          'Action',
          usedAbilityMessage.actionName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          usedAbilityMessage.actorId,
          'Action ID',
          usedAbilityMessage.actionId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          usedAbilityMessage.targetName,
          'Amount',
          usedAbilityMessage.amount
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          usedAbilityMessage.targetId,
          'Message Type',
          usedAbilityMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(usedAbilityMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Used an Ability" element to display the "Used an Ability" log
       * lines
       *
       * @param {object} rawData The parsed used an ability object
       *
       * @return {HTMLObject} The newly created element
       */
      function createUsedAbilityElement(message){
        // Container for the used messages
        const usedAbilityElement = document.createElement('details');
        usedAbilityElement.classList.add('card');
        usedAbilityElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        usedAbilityElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor using an Ability on a Target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = `<b>${message.actorName}</b> used <b>${message.actionName}</b>`;
        friendlyText += message.targetName ? ` on <b>${message.targetName}</b>` : '';
        friendlyText += !isNaN(message.amount) ? ' for <b>' + message.amount + '</b>': '';
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        usedAbilityElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createUsedAbilityTable(message)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        usedAbilityElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        usedAbilityElement.appendChild(rawView);

        // Used for searching
        usedAbilityElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          usedAbilityElement.dataset[key] = value;
        });

        return usedAbilityElement;
      }

      /**
       * Given a gainedEffectMessage, create an HTML table with it's data
       *
       * @param {object} effectMessage The parsed gained effect message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createGainedEffectTable(effectMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          effectMessage.actorName,
          'Effect',
          effectMessage.effectName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          effectMessage.actorId,
          'Effect ID',
          effectMessage.effectId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          effectMessage.targetName,
          'Duration',
          effectMessage.duration
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          effectMessage.targetId,
          'Message Type',
          effectMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(effectMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Gained Effect" element to display the "Gained an Effect" log
       * lines
       *
       * @param {object} message The parsed gained effect object
       *
       * @return {HTMLObject} The newly created element
       */
      function createGainedEffectElement(message){
        // Container for the Gained Effect messages
        const gainedEffectElement = document.createElement('details');
        gainedEffectElement.classList.add('card');
        gainedEffectElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        gainedEffectElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor applying the effect to the target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = '';
        if(message.actorName){
          friendlyText =`<b>${message.actorName}</b> applied <b>${message.effectName}</b> to <b>${message.targetName}</b>`;
        }
        else{
          friendlyText =`<b>${message.targetName}</b> gained <b>${message.actionName}</b>`;
        }
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        gainedEffectElement.appendChild(detailedView);

        // Table to hold the message information
        const gainedEffectTable = createGainedEffectTable(message)
        detailedView.appendChild(gainedEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        gainedEffectElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        gainedEffectElement.appendChild(rawView);

        // Used for searching
        gainedEffectElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          gainedEffectElement.dataset[key] = value;
        });

        return gainedEffectElement;
      }

      /**
       * Given a gainedEffectMessage, create an HTML table with it's data
       *
       * @param {object} effectMessage The parsed gained effect message.
       *
       * @return {HTMLObject} The newly created table element
       */
      function createLostEffectTable(effectMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          effectMessage.actorName,
          'Effect',
          effectMessage.effectName
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Actor ID',
          effectMessage.actorId,
          'Effect ID',
          effectMessage.effectId
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Target',
          effectMessage.targetName,
          'Duration',
          effectMessage.duration
        ]);
        detailsTable.appendChild(thirdRow);

        const fourthRow = createTableRowFromArray([
          'Target ID',
          effectMessage.targetId,
          'Message Type',
          effectMessage.messageType
        ]);
        detailsTable.appendChild(fourthRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(effectMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Lost an Effect" element to display the "Lost an Effect" log
       * lines
       *
       * @param {object} message The parsed lost an effect object
       *
       * @return {HTMLObject} The newly created element
       */
      function createLostEffectElement(message){
        // Container for the Gained Effect messages
        const lostEffectElement = document.createElement('details');
        lostEffectElement.classList.add('card');
        lostEffectElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        lostEffectElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor applying the effect to the target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = `<b>${message.actorName}</b> removed <b>${message.effectName}</b> from <b>${message.targetName}</b>`;
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        lostEffectElement.appendChild(detailedView);

        // Table to hold the message information
        const lostEffectTable = createLostEffectTable(message)
        detailedView.appendChild(lostEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        lostEffectElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        lostEffectElement.appendChild(rawView);

        // Used for searching
        lostEffectElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          lostEffectElement.dataset[key] = value;
        });

        return lostEffectElement;
      }

      /**
       * Given a gainedEffectMessage, create an HTML table with it's data
       *
       * @param {object} healthUpdateMessage The parsed health Update message
       *
       * @return {HTMLObject} The newly created table element
       */
      function createRegenTickTable(healthUpdateMessage){
        const detailsTable = document.createElement('table');
        detailsTable.classList.add('itemDetailsTable');

        const firstRow = createTableRowFromArray([
          'Actor',
          healthUpdateMessage.actorName,
          'Actor ID',
          healthUpdateMessage.actorId
        ]);
        detailsTable.appendChild(firstRow);

        const secondRow = createTableRowFromArray([
          'Current HP',
          healthUpdateMessage.currentHp,
          'Total HP',
          healthUpdateMessage.totalHp
        ]);
        detailsTable.appendChild(secondRow);

        const thirdRow = createTableRowFromArray([
          'Current MP',
          healthUpdateMessage.currentMp,
          'Total MP',
          healthUpdateMessage.totalMp
        ]);
        detailsTable.appendChild(thirdRow);

        // Fifth Row ///////////////////////////////////////////////////////////
        const fifthRow = document.createElement('tr');
        detailsTable.appendChild(fifthRow);

        // Timestamp
        const timestampColumnElement = document.createElement('td');
        timestampColumnElement.colSpan = 4;
        fifthRow.appendChild(timestampColumnElement);
        const timestampElement = document.createTextNode(healthUpdateMessage.timestamp);
        timestampColumnElement.appendChild(timestampElement);

        return detailsTable;
      }

      /**
       * Create a "Health update" element to display the "Health update" log lines
       *
       * @param {object} message The parsed health Update message
       *
       * @return {HTMLObject} The newly created element
       */
      function createHealthUpdateElement(message){
        // Container for the Gained Effect messages
        const healthUpdateElement = document.createElement('details');
        healthUpdateElement.classList.add('card');
        healthUpdateElement.classList.add('itemContainer');

        // Container for the friendly view elements
        const friendlyViewElement = document.createElement('summary');
        friendlyViewElement.classList.add('itemFriendlyView');
        healthUpdateElement.appendChild(friendlyViewElement);

        // Timestamp
        const friendlyTimestampElement = document.createElement('span');
        const timestamp = new Date(message.timestamp);
        friendlyTimestampElement.innerHTML = convertDateToFriendlyWithMilliseconds(timestamp);
        friendlyViewElement.appendChild(friendlyTimestampElement);

        // Actor applying the effect to the target
        const friendlyActorElement = document.createElement('span');
        let friendlyText = `<b>${message.actorName}</b>`;
        friendlyText += ` HP (${message.currentHp}/${message.totalHp})`;
        friendlyText += ` MP (${message.currentMp}/${message.totalMp})</b>`;
        friendlyActorElement.innerHTML = friendlyText;
        friendlyViewElement.appendChild(friendlyActorElement);

        // Container for the detailed view
        const detailedView = document.createElement('div');
        healthUpdateElement.appendChild(detailedView);

        // Table to hold the message information
        const lostEffectTable = createRegenTickTable(message)
        detailedView.appendChild(lostEffectTable);

        // Parsed message view
        const parsedView = createCodeBlock(
          (({raw, ...others }) => others)(message)
        );
        healthUpdateElement.appendChild(parsedView);

        // Raw message view
        const rawView = createCodeBlock(message.raw);
        healthUpdateElement.appendChild(rawView);

        // Used for searching
        healthUpdateElement.dataset.friendlyText = friendlyViewElement.innerText;
        Object.entries(message).forEach(([key, value]) => {
          healthUpdateElement.dataset[key] = value;
        });

        return healthUpdateElement;
      }

      /*
      appendElementToMain(
        createGainedEffectElement(
          parseMessageGainEffect(
            createFakeMessageGainEffectMessage()
          )
        )
      );
      */
    </script>
  </footer>
</html>
